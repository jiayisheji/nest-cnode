# 使用 Mongoose 设置 MongoDB 数据库

学习如何创建 `API` 时，重要的事情是如何存储数据。在这篇文章中，我们将研究如何使用 [MongoDB](https://www.mongodb.com/) 和 [NestJS](https://docs.nestjs.com/techniques/mongodb) 来实现这一点。为了使数据库的管理更加方便，我们使用了一个叫做 [Mongoose](https://mongoosejs.com/) 的对象关系映射(ORM)工具。为了更好地理解，我们还研究了一些 `mongo` 查询。通过这样做，我们可以借助 `ORM` 给我们带来的好处。

`MongoDB` 的设计原则与传统的 `SQL` 数据库有很大的不同。`MongoDB` 不是用表和行表示数据，而是将数据存储为类似 `json` 的文档。因此，对于熟悉 `JavaScript` 的开发人员来说，它相对容易掌握。

`MongoDB` 中的文档由键和值对组成。它们的重要方面是，在给定集合的不同文档中，键可以不同。这是 `MongoDB` 和 `SQL` 数据库之间的一个很大的区别。它使 `MongoDB` 更加灵活，结构更松散。因此，它既可以被视为优点，也可以被视为缺点。

## MongoDB 的优点和缺点

由于 `MongoDB` 和 `SQL` 数据库差别如此之大，为给定的工作选择正确的工具是至关重要的。由于 `NoSQL` 数据库对数据的限制较少，因此对于快速发展的应用程序来说，它可能是一个不错的选择。我们仍然可能需要在模式更改时更新数据。

例如，我们可能想要添加一个包含用户头像 `URL` 的新属性。当它发生时，我们仍然应该处理不包含我们的新属性的 `document`。我们可以通过编写一个为旧 `document` 设置默认值的脚本来实现这一点。或者，我们可以假设这个字段可能缺失，并在应用程序级别上以不同的方式处理它。

相反，向现有 `SQL` 数据库添加新属性需要编写显式处理新属性的迁移。在很多情况下，这看起来有点烦人。但是，对于 `MongoDB`，这不是必需的。这可能会使工作更容易、更快捷，但我们需要小心，不要丢失数据的完整性。

`SQL` 数据库将数据保存在由列和行组成的表中。设计过程的很大一部分是定义上述表之间的关系。例如，用户可以是一篇文章的作者。另一方面，`MongoDB` 是非关系数据库。因此，虽然我们可以用 `MongoDB` 模拟 `sql` 风格的关系，但它们不会那么高效和万无一失。

## 将 MongoDB 与 Nestjs 一起使用

使用 `MongoDB` 数据库启动我们开发的最直接方法是使用 `Docker`。

首先要做的是安装 [Docker](https://docs.docker.com/get-docker/) 和 [Docker Compose](https://docs.docker.com/compose/install/)。现在，我们需要创建一个 `docker-compose.yml` 文件并运行它。

```yml
version: '3.8'
services:
  mongo:
    image: mongo:latest
    environment:
      MONGO_INITDB_ROOT_USERNAME: ${MONGO_USERNAME}
      MONGO_INITDB_ROOT_PASSWORD: ${MONGO_PASSWORD}
      MONGO_INITDB_DATABASE: ${MONGO_DATABASE}
    volumes:
      - ./.docker/mongo_data:/data/db
      - ./init.d/mongo-init.sh:/docker-entrypoint-initdb.d/mongo-init.sh
    ports:
      - '27017:27017'
```

在上面，你可以看到我们引用了一些变量。让我们把它们放到 `.env` 文件中:

```env
#
# database mongoDB
#
MONGO_HOST=localhost:27017
MONGO_USERNAME=nest-cnode
MONGO_PASSWORD=nest-cnode
MONGO_DATABASE=nest_cnode
```

启动 `docker`

```bash
docker-compose up -d
```

对于连接到 `MongoDB` 数据库并管理数据，我们使用最流行的库是 `Mongoose`。

```bash
npm install --save @nestjs/mongoose mongoose
```

让我们使用 `Mongoose` 连接到我们的数据库。为此，我们需要定义一个 [URI connection string](https://www.mongodb.com/docs/manual/reference/connection-string/)

```ts
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { ConfigModule, ConfigService } from '@nestjs/config';
import PostsModule from './posts/posts.module';
import * as Joi from '@hapi/joi';

@Module({
  imports: [
    ConfigModule.forRoot({
      validationSchema: Joi.object({
        MONGO_USERNAME: Joi.string().required(),
        MONGO_PASSWORD: Joi.string().required(),
        MONGO_DATABASE: Joi.string().required(),
        MONGO_HOST: Joi.string().required(),
      }),
    }),
    MongooseModule.forRootAsync({
      imports: [ConfigModule],
      useFactory: async (configService: ConfigService) => {
        const username = configService.get('MONGO_USERNAME');
        const password = configService.get('MONGO_PASSWORD');
        const database = configService.get('MONGO_DATABASE');
        const host = configService.get('MONGO_HOST');

        return {
          uri: `mongodb://${username}:${password}@${host}`,
          database,
        };
      },
      inject: [ConfigService],
    }),
  ],
})
export class AppModule {}
```

## 保存和检索数据

在 `MongoDB` 中，我们对 `collection` 组中的 `document` 进行操作。要开始使用 `MongoDB` 和 `Mongoose` 保存和检索数据，我们首先需要定义一个 `schema`。这乍一看可能令人惊讶，因为 `MongoDB` 被认为是无模式的。尽管 `MongoDB` 很灵活，`Mongoose` 使用 `schema` 在 `collection` 上操作并定义其形状。

### Mongoose 中 Schema、Model、Document 的关系

- Schema: 一种以文件形式存储的数据库模型骨架，不具备数据库的操作能力
- Model: 由 `Schema` 发布生成的模型，具有抽象属性和数据库操作能力
- Document: 由 `Model` 创建的实例, 也能操作数据库

`Schema` 生成 `Model`，`Model` 创造 `Document`，`Model` 和 `Document` 都可对数据库操作造成影响，但 `Model` 比 `Document` 更具操作性。

### 定义 schema

每个 `schema` 都映射到一个 `MongoDB collection`。它还定义了其中 `document` 的形状。

```ts
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document } from 'mongoose';

export type PostDocument = Post & Document;

@Schema()
export class Post {
  @Prop()
  title: string;

  @Prop()
  content: string;
}

export const PostSchema = SchemaFactory.createForClass(Post);
```

使用 `@Schema()` 装饰器，我们可以将类标记为 `schema` 定义并将其映射到 `MongoDB collection`。我们使用 `@Prop()` 装饰器来定义 `document` 的属性。多亏了 `TypeScript` 元数据，我们的属性的 [SchemaTypes](https://mongoosejs.com/docs/schematypes.html) 可以自动推断出来。

### 使用 model

Mongoose 将我们的 `schema` 包装成 `model`。我们可以使用它们来创建和读取 `document`。为了让我们的服务使用 `model`，我们需要将其添加到模块中。

```ts
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import PostsController from './posts.controller';
import PostsService from './posts.service';
import { Post, PostSchema } from './post.schema';

@Module({
  imports: [MongooseModule.forFeature([{ name: Post.name, schema: PostSchema }])],
  controllers: [PostsController],
  providers: [PostsService],
})
export class PostsModule {}
```

我们还需要将 `model` 注入到我们的服务中：

```ts
import { Model } from 'mongoose';
import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Post, PostDocument } from './post.schema';

@Injectable()
export class PostsService {
  constructor(@InjectModel(Post.name) private postModel: Model<PostDocument>) {}
}
```

一旦我们这样做了，我们就可以开始与我们的 `collection` 交互。

### CURD

#### 获取全部实体

我们能做的最基本的事情是获取所有 `document` 的列表。为此，我们需要 `find()` 方法

```ts
@Injectable()
class PostsService {
  constructor(@InjectModel(Post.name) private postModel: Model<PostDocument>) {}

  async findAll() {
    return this.postModel.find();
  }
}
```

#### 获取单条实体

我们创建的每个 `document` 都被分配了一个字符串 `id`。如果想获取单个 `document` ，可以使用 `findById()` 方法

```ts
@Injectable()
class PostsService {
  constructor(@InjectModel(Post.name) private postModel: Model<PostDocument>) {}

  async findOne(id: string) {
    const post = await this.postModel.findById(id);
    if (!post) {
      throw new NotFoundException();
    }
    return post;
  }
}
```

#### 创建实体

我们现在可以在创建 `model` 的新实例并保存它时使用它

```ts
@Injectable()
class PostsService {
  constructor(@InjectModel(Post.name) private postModel: Model<PostDocument>) {}

  async create(postData: PostDto) {
    const createdPost = new this.postModel(postData);
    return createdPost.save();
  }
}
```

#### 修改实体

我们可能还需要更新已经创建的实体。为此，我们可以使用 `findByIdAndUpdate()` 方法

```ts
@Injectable()
class PostsService {
  constructor(@InjectModel(Post.name) private postModel: Model<PostDocument>) {}

  async update(id: string, postData: PostDto) {
    const post = await this.postModel.findByIdAndUpdate(id, postData).setOptions({ overwrite: true, new: true });
    if (!post) {
      throw new NotFoundException();
    }
    return post;
  }
}
```

上面，正在发生一些重要的事情。多亏使用了 `new: true` 参数，使得 `findByIdAndUpdate()` 方法返回更新后实体给我们。

通过使用 `overwrite: true`。我们表示希望替换整个 `document`，而不是执行部分更新。这就是 `PUT` 和 `PATCH` 2 个 `HTTP` 方法的区别所在。

#### 删除实体

要删除现有实体，需要使用 `findByIdAndDelete()` 方法

```ts
@Injectable()
class PostsService {
  constructor(@InjectModel(Post.name) private postModel: Model<PostDocument>) {}

  async delete(id: string) {
    const result = await this.postModel.findByIdAndDelete(id);
    if (!result) {
      throw new NotFoundException();
    }
  }
}
```

## 总结

在本文中，我们学习了如何将 `MongoDB` 与 `NestJS` 一起使用的基本知识。为此，我们使用 `Docker Compose` 创建了一个本地 `MongoDB` 数据库，并将其与 `NestJS` 使用 `Mongoose` 连接。为了更好地理解 `MongoDB`，关于 `MongoDB` 还有很多东西要讲，所以请继续关注下一篇文章。
