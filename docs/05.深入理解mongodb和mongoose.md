# 深入理解 MongoDB 和 Mongoose

## 使用 Mongoose 实现 MongoDB 关系

`MongoDB` 最一个非关系型的数据库。因此，如果关系是数据库设计的重要组成部分，那么它可能不是最合适的。也就是说，我们肯定可以通过直接使用嵌入文档的引用来模拟 `sql` 样式的关系。

`MongoDB` 中的数据以“库”—“集合”—“文档”—“字段”结构进行储存。这种结构咋看和传统关系型数据库的“库”—“表”—“行”—“列”结构非常像。但是，`MongoDB` 不需要预先定义表结构，数据的字段可以任意变动，并发写入速度也远远超过传统关系型数据库。

### 数据库设计三范式

说到设计关系型数据库时，就会想到关系型数据设计三范式。遵从不同的规范要求，设计出合理的关系型数据库，这些规范被称作范式。越高的范式数据库的冗余度就越低。

#### 第一范式(确保每列保持原子性)

第一范式是最基本的范式。如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式。

第一范式具有原子性，是对属性的原子性约束，要求属性具有原子性，不可再分解。

具体来说，第一范式要求关系模式中的每个属性都是不可再分解的基本数据项，也就是说，每个属性都只能包含一个值。例如，一个学生的信息包括学号、姓名、性别、年龄等属性，其中学号、姓名、性别、年龄都是原子性的属性，而如果将姓名拆分成姓和名两个属性，则不符合第一范式的要求。因此，第一范式是关系数据库设计的基础，它可以保证数据的完整性和一致性，提高数据的存储效率和查询效率。

#### 第二范式(确保表中的每列都和主键相关)

第二范式在第一范式的基础之上更进一层。第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。也就是说在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。

第二范式具有主键列与非主键列遵循完全函数依赖关系，是对记录的惟一性约束，要求记录有惟一标识，即实体的惟一性。

具体来说，如果一个关系模式中存在多个候选键，那么每个非主属性都必须完全依赖于所有候选键，而不是只依赖于其中的一部分。例如，一个订单信息表包括订单号、客户号、产品号、产品名称、产品单价、产品数量等属性，其中订单号是主键，客户号和产品号是候选键。如果产品名称只依赖于产品号，而不依赖于客户号，那么就不符合第二范式的要求。因此，第二范式可以保证数据的完整性和一致性，避免数据冗余和不一致，提高数据的存储效率和查询效率。

在实际的数据库设计中，通常需要同时满足第一范式和第二范式的要求，以保证数据的完整性和一致性。如果一个关系模式不满足第一范式或第二范式的要求，就需要进行适当的调整和优化，以满足这些要求。

#### 第三范式(确保每列都和主键列直接相关,而不是间接相关)

第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。

第三范式具有非主键列之间没有传递函数依赖关系，是对字段冗余性的约束，即任何字段不能由其他字段派生出来，它要求字段没有冗余。

具体来说，如果一个关系模式中存在多个非主属性，那么每个非主属性都必须直接依赖于主键，而不是依赖于其他非主属性。例如，一个学生选课信息表包括学号、课程号、课程名称、教师号、教师姓名等属性，其中学号和课程号是主键。如果教师姓名只依赖于教师号，而不依赖于课程号，那么就不符合第三范式的要求。因此，第三范式可以避免数据冗余和不一致，提高数据的存储效率和查询效率。

在实际的数据库设计中，通常需要同时满足第一范式、第二范式和第三范式的要求，以保证数据的完整性和一致性。如果一个关系模式不满足这些要求，就需要进行适当的调整和优化，以满足这些要求。

> 高级别的范式都是建立在低级别之上，不能反向依赖。范式目的是避免数据冗余和不一致，提高数据的存储效率和查询效率。

### 一对一

通过一对一的关系，第一个集合中的文档在第二个集合中只有一个匹配的文档，反之亦然。比如常用的地址：

```ts
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document } from 'mongoose';

export type AddressDocument = Address & Document;

@Schema()
export class Address {
  _id: string;

  @Prop()
  province: string;

  @Prop()
  city: string;

  @Prop()
  street: string;
}

export const AddressSchema = SchemaFactory.createForClass(Address);
```

在我们的应用程序中，很有可能只有一个用户被分配到特定的地址。因此，这是一对一关系的一个很好的例子。因此，我们可以利用嵌入文档，这是一种性能非常好的方法。

为了使它正常工作，我们需要显式地将 `AddressSchema` 传递给 `@Prop` 装饰器

```ts
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, ObjectId } from 'mongoose';
import { Address, AddressSchema } from './address.schema';

export type UserDocument = User & Document;

@Schema()
export class User {
  _id: ObjectId;

  @Prop({ unique: true })
  email: string;

  @Prop()
  name: string;

  @Prop()
  password: string;

  @Prop({ type: AddressSchema })
  address: Address;
}

export const UserSchema = SchemaFactory.createForClass(User);
```

当我们为用户创建文档时，`MongoDB` 还为地址创建文档。它还给它一个独特的 `ObjectId`。

在我们的一对一关系示例中，用户只有一个地址。而且，一个地址只属于一个用户。既然是这种情况，将用户直接嵌入到用户的文档中是有意义的。这样，`MongoDB` 可以快速返回。让我们使用 `MongoDB` 指南来确保这是这里的情况。

### 一对多（多对一）

当第一个集合中的文档可以链接到第二个集合中的多个文档时，我们实现一对多和多对一关系。第二个集合中的文档只能链接到第一个集合中的一个文档。

很好的例子是帖子和作者，其中用户可以是多个帖子的作者。但是在我们的实现中，一篇帖子只能有一个作者。

```ts
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, ObjectId } from 'mongoose';
import * as mongoose from 'mongoose';
import { User } from '../users/user.schema';

export type PostDocument = Post & Document;

@Schema()
export class Post {
  _id: ObjectId;

  @Prop()
  title: string;

  @Prop()
  content: string;

  @Prop({ type: mongoose.Schema.Types.ObjectId, ref: User.name })
  author: User;
}

export const PostSchema = SchemaFactory.createForClass(Post);
```

由于定义了上述引用，我们现在可以将用户分配给帖子中的 `author` 属性。

```ts
import { Model } from 'mongoose';
import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Post, PostDocument } from './post.schema';
import PostDto from './dto/post.dto';
import { User } from '../users/user.schema';

@Injectable()
export class PostsService {
  constructor(@InjectModel(Post.name) private postModel: Model<PostDocument>) {}

  async create(postData: PostDto, author: User) {
    const createdPost = new this.postModel({
      ...postData,
      author,
    });
    return createdPost.save();
  }

  async findAll() {
    return this.postModel.find().populate('author');
  }

  // ...
}
```

像这样保存帖子的结果是将作者的 `id` 存储在数据库中。

它的一个优点是，我们可以使用 `Mongoose` 提供的 `populate` 方法轻松地将 `id` 替换为实际数据。

执行 `findAll()` 操作的结果是 `Mongoose` 返回作者的数据和帖子。

#### 引用与内嵌

在上面的代码中，我们将作者的 `id` 存储在帖子的文档中。我们也可以反过来做，将帖子 id 存储在作者的文档中。在做决定时，我们需要考虑一些因素。

首先，我们需要考虑需要存储多少引用。想象一下这样一种情况：我们希望在服务器机房中存储不同机器的日志。我们需要记住，`MongoDB` 文档的最大大小是 `16MB`。如果在 `Machine` 文档中存储 `Log` 文档的 `id` 数组，理论上，可能会在某个时刻耗尽空间。我们可以将机器的单个 `id` 存储在 `Log` 文档中。

另一件需要考虑的事情是我们最常运行的查询是什么。例如，在帖子列表和作者的实现中，如果我们有帖子，那么检索作者的数据就很容易。这是因为我们将作者的 id 存储在了文章的文档中。另一方面，检索单个用户的帖子列表将更耗时。为此，我们需要查询所有的帖子并检查作者的 id。

我们可以实现双向引用，并将引用存储在两边来解决上述问题。上述方法可以加快一些查询的速度，但需要我们花更多的精力来保持数据的一致性。

我们还可以将帖子的文档嵌入到用户的文档中。这样做的好处是不需要对数据库执行额外的查询来获取丢失的信息。但是，不幸的是，这将使获得一个特定的帖子更加困难。

### 多对多

另一个需要考虑的重要关系是多对多。第一个集合中的文档可以引用第二个集合中的多个文档，反之亦然。

可以属于多个分类的帖子就是一个很好的例子。另外，一个分类可以属于多个帖子。首先，让我们定义分类的 `Schema`。

```ts
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, ObjectId } from 'mongoose';

export type CategoryDocument = Category & Document;

@Schema()
export class Category {
  _id: ObjectId;

  @Prop()
  name: string;
}

export const CategorySchema = SchemaFactory.createForClass(Category);
```

现在我们可以在帖子的 `Schema` 中使用它。

```ts
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, ObjectId } from 'mongoose';
import * as mongoose from 'mongoose';
import { User } from '../users/user.schema';
import { Category } from '../categories/category.schema';

export type PostDocument = Post & Document;

@Schema()
export class Post {
  _id: ObjectId;

  @Prop()
  title: string;

  @Prop()
  content: string;

  @Prop({ type: mongoose.Schema.Types.ObjectId, ref: User.name })
  author: User;

  @Prop({
    type: [{ type: mongoose.Schema.Types.ObjectId, ref: Category.name }],
  })
  categories: Category;
}

export const PostSchema = SchemaFactory.createForClass(Post);
```

值得注意的一点是，我们还可以在保存文档之后立即使用 `populate` 方法。

```ts
import { Model } from 'mongoose';
import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Post, PostDocument } from './post.schema';
import PostDto from './dto/post.dto';
import { User } from '../users/user.schema';

@Injectable()
export class PostsService {
  constructor(@InjectModel(Post.name) private postModel: Model<PostDocument>) {}

  async create(postData: PostDto, author: User) {
    const createdPost = new this.postModel({
      ...postData,
      author,
    });
    await createdPost.populate('categories');
    return createdPost.save();
  }
}
```

> 上面的一件重要的事情是，我们在 `Mongoose` 的 `Document` 实例上调用 `populate` 方法。

## Mongoose 定义虚拟属性

我们使用 `Mongoose` 在模式中定义属性，并使用文档的模型。我们还定义了集合之间的各种关系。通过 `Mongoose` 我们还可以利用 `MongoDB` 中没有存储的虚拟属性。要理解它们，我们首先要掌握 `getter` 和 `setter` 的概念。

### getter 和 setter

当在具有 `getter` 和 `setter` 的文档中获取和设置属性时，可以执行自定义逻辑。

#### getter

通过使用 `getter` 我们可以在检索文档数据时修改它。让我们创建一个示例，当用户有一个手机号时，我们希望在响应 `API` 请求时对其进行模糊处理。

```ts
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document } from 'mongoose';

export type UserDocument = User & Document;

@Schema({
  toJSON: {
    getters: true,
  },
})
export class User {
  @Prop({
    get: (phoneNumber: string) => {
      if (!phoneNumber) {
        return;
      }
      return phoneNumber.replace(/(\d{3})\d*(\d{4})/, '$1****$2');
    },
  })
  phoneNumber?: string;

  // ...
}

export const UserSchema = SchemaFactory.createForClass(User);
```

当我们从 `API` 返回文档时，`NestJS` 将数据序列化。当这种情况发生时，就会在 `Mongoose` 的模型上调用 `toJSON` 方法。因此，如果我们想要考虑我们的 `getter`，我们需要显式地为我们的配置添加 `getters: true`。

> Document 也有 `toObject` 方法，我们可以以类似的方式自定义它。

`Mongoose` 为我们的模式分配 `id` 字段的虚拟 `getter`。它现在出现在响应中，因为我们打开了 `getters` 到 `getters: true`。

有时我们希望访问原始未修改的属性。为此，我们可以使用 `Document.prototype.get()` 方法。

#### setter

使用 `setter` 我们可以在将数据保存到数据库之前修改数据。

```ts
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, ObjectId } from 'mongoose';

export type PostDocument = Post & Document;

@Schema()
export class Post {
  @Prop()
  title: string;

  @Prop({
    set: (content: string) => {
      return content.trim();
    },
  })
  content: string;

  // ...
}

export const PostSchema = SchemaFactory.createForClass(Post);
```

由于做了上面的工作，我们现在从内容字符串的两端删除空白。

虽然 `setter` 是一种有效的技术，但我们可能更好将此逻辑放在服务中以提高可读性。然而，即使是这种情况，`setter` 也是值得了解的。

### 虚拟属性

`virtual` 是我们可以获取和设置的属性，但它不存储在数据库中。让我们定义一个简单的用例示例。

```ts
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document } from 'mongoose';

export type UserDocument = User & Document;

@Schema()
export class User {
  @Prop()
  firstName: string;

  @Prop()
  lastName: string;

  @Prop()
  fullName: string;

  // ...
}

export const UserSchema = SchemaFactory.createForClass(User);
```

不幸的是，上述方法是有缺陷的。如果我们将 `fullName` 属性持久化到 `MongoDB` 中，我们将复制信息，因为我们已经有了 `firstName` 和 `lastName`。更合适的方法是基于其他属性动态创建 `fullName`。

我们可以通过虚拟属性实现上述目的。因此，让我们将它与 `getter` 一起创建。

```ts
UserSchema.virtual('fullName').get(function (this: UserDocument) {
  return `${this.firstName} ${this.lastName}`;
});
```

这样我们就可以移除使用 `@Prop()` 装饰器装饰的 `fullName` 属性。

由于添加了 `virtual: true`，我们的虚拟属性在将文档转换为 JSON 时是可见的。尽管我们可以在响应中看到 `fullName`，但它并没有保存到数据库中。

使用 `virtual` 我们还可以创建 `setter`。例如，我们可以使用它们一次设置多个属性。

```ts
UserSchema.virtual('fullName')
  .get(function (this: UserDocument) {
    return `${this.firstName} ${this.lastName}`;
  })
  .set(function (this: UserDocument, fullName: string) {
    const [firstName, lastName] = fullName.split(' ');
    this.set({ firstName, lastName });
  });
```

上面，我们基于 `fullName` 设置了 `firstName` 和 `lastName` 属性。

> **注意**：在虚拟属性 `get` 和 `set` 要使用普通函数，切记不能使用箭头函数，不然找不到 `this`。

### 填充虚拟属性

虚拟属性的一个方便特性是使用它们 `populate` 来自另一个集合的文档。

前面我们创建了 `Post`，使用它存储对 `author` 的引用。

因此，当我们获取 `User` 文档时，我们没有关于任何帖子的信息。我们可以使用虚拟属性来解决这个问题。

```ts
UserSchema.virtual('posts', {
  ref: 'Post',
  localField: '_id',
  foreignField: 'author',
});
```

最后一步是调用 `populate` 和用户的文档。当我们这样做时，我们还可以填充嵌套的 `categories` 属性。

```ts
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { UserDocument, User } from './user.schema';

@Injectable()
export class UsersService {
  constructor(@InjectModel(User.name) private userModel: Model<UserDocument>) {}

  async getById(id: string) {
    const user = await this.userModel.findById(id).populate({
      path: 'posts',
      populate: {
        path: 'categories',
      },
    });

    if (!user) {
      throw new NotFoundException();
    }

    return user;
  }
}
```

## Mongoose 定义索引

我们的数据库越大，我们的查询在计算能力方面的要求就越高。解决这个问题的常用方法是创建索引。接下来，我们将探讨这个概念，并使用 `MongoDB` 和 `Mongoose` 创建索引。

在执行 `MongoDB` 查询时，数据库必须扫描给定集合中的每个文档以查找匹配的文档。`MongoDB` 可以限制记录的数量，以检查我们的数据库中是否有适当的索引。由于索引可以更容易地搜索数据库中的文档，因此它可以加快查找、更新和删除的速度。

在底层，索引是一种数据结构，它以一种易于遍历的方式存储集合数据的一小部分。它包括文档特定字段的有序值。它使 `MongoDB` 的索引类似于 `PostgreSQL` 等数据库中的索引。

当我们定义索引时，`MongoDB` 需要存储额外的数据来加快查询速度。但是，不幸的是，它降低了写查询的速度。它也会占用更多的内存。因此，我们需要节约地创建索引。

### 唯一索引

唯一索引确保不存储重复的值。我们可以通过将 `unique: true` 传递给 `@Prop` 装饰器来创建它。

```ts
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, ObjectId } from 'mongoose';

export type UserDocument = User & Document;

@Schema({
  toJSON: {
    getters: true,
    virtuals: true,
  },
})
export class User {
  _id: ObjectId;

  @Prop({ unique: true })
  username: string;

  // ...
}

const UserSchema = SchemaFactory.createForClass(User);
```

重要的是要知道 `MongoDB` 在创建集合时在 `id` 字段上创建一个唯一的索引。因此，我们有时将其称为首要索引。

当我们使用没有索引的字段对文档进行排序时，`MongoDB` 在查询时执行排序。这需要花费时间和资源，并使我们的应用程序响应更慢。但是，拥有正确的索引可以帮助我们避免在查询时对结果进行排序，因为结果已经在索引中排序了。

我们需要记住，使属性独一无二会创建索引并降低写查询的速度。

使用 `MongoDB`，我们还可以定义不使属性唯一的二级索引。

```ts
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, ObjectId } from 'mongoose';

export type PostDocument = Post & Document;

@Schema()
export class Post {
  _id: ObjectId;

  @Prop({ index: true })
  title: string;

  // ...
}

export const PostSchema = SchemaFactory.createForClass(Post);
```

通过以上操作，我们可以加快查询速度，例如，当我们查找具有特定标题的文章时。我们还通过按标题字母顺序排序来加快查询速度。

#### 文本索引

`MongoDB` 还实现了支持对字符串内容进行搜索查询的文本索引。要定义文本索引，需要使用 `index()` 方法。

```ts
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, ObjectId } from 'mongoose';

export type PostDocument = Post & Document;

@Schema()
export class Post {
  _id: ObjectId;

  @Prop()
  title: string;

  // ...
}

const PostSchema = SchemaFactory.createForClass(Post);

PostSchema.index({ title: 'text' });

export { PostSchema };
```

在设置文本索引时，可以利用 `$text` 操作符。它对用文本索引建立索引的字段的内容执行文本搜索。

> 一个集合不能设置多个文本索引。

让我们通过添加一个新的查询参数来实现搜索帖子的功能。

我们还需要将 `$text` 查询添加到服务中。

```ts
import { FilterQuery, Model } from 'mongoose';
import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Post, PostDocument } from './post.schema';

@Injectable()
export class PostsService {
  constructor(@InjectModel(Post.name) private postModel: Model<PostDocument>) {}

  async findAll(documentsToSkip = 0, limitOfDocuments?: number, startId?: string, searchQuery?: string) {
    const filters: FilterQuery<PostDocument> = startId
      ? {
          _id: {
            $gt: startId,
          },
        }
      : {};

    if (searchQuery) {
      filters.$text = {
        $search: searchQuery,
      };
    }

    const findQuery = this.postModel
      .find(filters)
      .sort({ _id: 1 })
      .skip(documentsToSkip)
      .populate('author')
      .populate('categories');

    if (limitOfDocuments) {
      findQuery.limit(limitOfDocuments);
    }

    const results = await findQuery;
    const count = await this.postModel.count();

    return { results, count };
  }

  // ...
}
```

由于上述，`MongoDB` 可以搜索我们的帖子的标题。

> 查询 `$text` 有更多的参数，比如 `$casesensisitive` 布尔值。[查看文档](https://www.mongodb.com/docs/manual/reference/operator/query/text/#op._S_text)

### 复合索引

`$text` 查询搜索用文本索引建立索引的所有字段。使用 `MongoDB` 我们可以创建复合索引，其中索引结构包含对多个字段的引用。

```ts
PostSchema.index({ title: 'text', content: 'text' });
```

由于做了上述工作，`$text` 查询将通过文章的标题和内容进行搜索。

除了文本索引，我们还可以创建常规的复合索引。

```ts
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, ObjectId } from 'mongoose';

export type UserDocument = User & Document;

@Schema({
  toJSON: {
    getters: true,
    virtuals: true,
  },
})
export class User {
  _id: ObjectId;

  @Prop()
  firstName: string;

  @Prop()
  lastName: string;

  // ...
}

const UserSchema = SchemaFactory.createForClass(User);

UserSchema.index({ firstName: 1, lastName: 1 });

export { UserSchema };
```

执行以上功能会在 `firstName` 和 `lastName` 字段上创建复合索引。它可以加快查询，例如我们寻找具有特定 `firstName` 和 `lastName` 的用户。

通过使用 `1` 为我们创建了一个升序索引。当使用 `-1` 时，我们创建了一个降序索引。方向对于单键索引并不重要，因为 `MongoDB` 可以任意方向遍历索引。不过，它对于复合索引来说可能很重要。[官方文档](https://www.mongodb.com/docs/manual/core/index-compound/#sort-order)和 [stackoverflow](https://stackoverflow.com/questions/10329104/why-does-direction-of-index-matter-in-mongodb) 页面提供了很好的解释。

## 使用 Mongoose 实现 MongoDB 事务管理

在使用数据库时，保持数据的完整性至关重要。例如，想象一下将钱从一个银行账户转到另一个账户。为此，我们需要执行两个单独的操作。首先，我们从第一个银行账户取钱。然后，我们将同样的金额添加到第二个帐户。

如果第二次操作在第一次成功时出于任何原因失败，我们就会得到数据库的无效状态。我们需要上述操作的全部成功或全部失败。我们可以通过事务来实现这一点。

### ACID

有效的事务需要具有以下属性。它们一起形成 [ACID](https://en.wikipedia.org/wiki/ACID)。

#### Atomicity

事务中的操作是单个单元。因此，它要么完全成功或失败。

#### Consistency

事务将数据库从一个有效状态移动到下一个有效状态。

#### Isolation

隔离属性确保多个事务可以并发发生，从而产生有效的数据库状态。为了更好地理解这一点，让我们继续上面的银行事务示例。在另一个事务中，资金应该存在一个账户或另一个账户中，而不是同时存在两个账户中。

#### Durability

一旦来自事务的更改被提交，它们应该会永久存在。

### MongoDB 和 Mongoose 的事务

幸运的是，`MongoDB` 从 4.0 版本开始就配备了对多文档事务的支持。我们可以告诉数据库我们进行了一个事务，它会跟踪我们所做的每一次更新。如果某些事情失败，那么数据库会回滚我们的所有更新。以上要求数据库做额外的工作，记录我们的更新并锁定相关的资源。试图对数据执行操作的其他客户机可能会被困在等待事务完成的过程中。因此，这是需要注意的。

### 运行复制品集

`MongoDB` 的事务只与[副本集](https://www.mongodb.com/docs/manual/replication/)一起工作，一组维护相同数据集的 `MongoDB` 进程。在本系列中，我们一直在使用 `docker-compose` 为我们运行 `MongoDB`。我们可以使用 `docker` 在本地运行副本集，也可以使用 [MongoDB atlas](https://www.mongodb.com/atlas/database)。

> 如果你想运行一个副本集，请查看 [stackoverflow](https://stackoverflow.com/questions/55916275/docker-compose-to-create-replication-in-mongodb) 上的这个页面。

### 删除用户

让我们实现一个删除用户的特性。当我们从数据库中删除用户时，我们还希望删除他们所写的所有帖子。

```ts
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { UserDocument, User } from './user.schema';
import PostsService from '../posts/posts.service';

@Injectable()
export class UsersService {
  constructor(
    @InjectModel(User.name) private userModel: Model<UserDocument>,
    private readonly postsService: PostsService
  ) {}

  async delete(userId: string) {
    const user = await this.userModel.findByIdAndDelete(userId).populate('posts');
    if (!user) {
      throw new NotFoundException();
    }
    const posts = user.posts;

    return this.postsService.deleteMany(posts.map((post) => post._id.toString()));
  }

  // ...
}
```

要完成上述操作，还需要在 `PostsService` 中定义 `deleteMany`。

```ts
import { Model } from 'mongoose';
import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Post, PostDocument } from './post.schema';

@Injectable()
export class PostsService {
  constructor(@InjectModel(Post.name) private postModel: Model<PostDocument>) {}

  async deleteMany(ids: string[]) {
    return this.postModel.deleteMany({ _id: ids });
  }

  // ...
}
```

上述代码的缺点是 `delete` 方法可能部分成功。当这种情况发生时，我们删除了用户，但是没有作者的文章保留在数据库中。我们可以通过定义事务来处理上述问题。

要启动一个事务，我们需要访问我们与 `MongoDB` 建立的连接。为此，我们可以使用 `@InjectConnection` 装饰器：

```ts
import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { UserDocument, User } from './user.schema';
import PostsService from '../posts/posts.service';
import { InjectConnection } from '@nestjs/mongoose';
import * as mongoose from 'mongoose';

@Injectable()
export class UsersService {
  constructor(
    @InjectModel(User.name) private userModel: Model<UserDocument>,
    private readonly postsService: PostsService,
    @InjectConnection() private readonly connection: mongoose.Connection
  ) {}

  // ...
}
```

### 控制事务

有两种使用 `Mongoose` 处理事务的方法。为了完全控制它，我们可以调用 `startTransaction` 方法：

```ts
const session = await this.connection.startSession();
session.startTransaction();
```

当我们表示一切正常时，我们需要调用 `session.commitTransaction()`。这将把我们的更改写入数据库。

为了表明我们要在给定的会话中执行操作，我们需要使用 `session()` 方法。

```ts
async delete(userId: string) {
  const session = await this.connection.startSession();

  session.startTransaction();
  try {
    const user = await this.userModel
      .findByIdAndDelete(userId)
      .populate('posts')
      .session(session);

    if (!user) {
      throw new NotFoundException();
    }
    const posts = user.posts;

    await this.postsService.deleteMany(
      posts.map((post) => post._id.toString()),
    );
    await session.commitTransaction();
  } catch (error) {
    await session.abortTransaction();
    throw error;
  } finally {
    session.endSession();
  }
}
```

尽管如此，上述代码还是一个重要的问题。虽然在事务中删除了用户，但在删除帖子时没有这样做。要在会话中删除帖子，我们需要修改 `postsService.deleteMany` 方法：

```ts
import { Model } from 'mongoose';
import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Post, PostDocument } from './post.schema';
import * as mongoose from 'mongoose';

@Injectable()
export class PostsService {
  constructor(@InjectModel(Post.name) private postModel: Model<PostDocument>) {}

  async deleteMany(ids: string[], session: mongoose.ClientSession | null = null) {
    return this.postModel.deleteMany({ _id: ids }).session(session);
  }

  // ...
}
```

通过向 `deleteMany` 方法添加可选的会话参数，我们可以删除事务中的帖子。让我们使用它：

```ts
async delete(userId: string) {
  const session = await this.connection.startSession();

  session.startTransaction();
  try {
    const user = await this.userModel
      .findByIdAndDelete(userId)
      .populate('posts')
      .session(session);

    if (!user) {
      throw new NotFoundException();
    }
    const posts = user.posts;

    await this.postsService.deleteMany(
      posts.map((post) => post._id.toString()),
      session,
    );
    await session.commitTransaction();
  } catch (error) {
    await session.abortTransaction();
    throw error;
  } finally {
    session.endSession();
  }
}
```

如果由于某种原因删除帖子失败，用户也不会从数据库中删除。正因为如此，整个操作要么整体成功，要么彻底失败。

### 使用事务的更简单的方法

我们可以使用 `session.withTransaction()` 助手，而不是手动控制事务的每一步。

```ts
async delete(userId: string) {
  const session = await this.connection.startSession();

  await session.withTransaction(async () => {
    const user = await this.userModel
      .findByIdAndDelete(userId)
      .populate('posts')
      .session(session);

    if (!user) {
      throw new NotFoundException();
    }
    const posts = user.posts;

    await this.postsService.deleteMany(
      posts.map((post) => post._id.toString()),
      session,
    );
  });

  session.endSession();
}
```

请注意，我们不再需要调用 `startTransaction()`、`commitTransaction()` 和 `abortTransaction()`。但是，我们仍然需要使用 `endSession()` 方法结束会话。

## 实现分页

当我们的应用程序增长时，数据库也会增长。在某些情况下，我们可能会从端点返回大量数据。例如，它可能被证明是前端应用程序无法处理的。因此，我们可能需要通过只返回记录的一部分来对记录进行分页。本文探讨了 `Mongoose` 实现这一目标的不同方法，并考虑了它们的优缺点。

### 偏移分页

最直接的分页形式是期望用户提供他们想要跳过的文档的数量。此外，他们可以声明他们想要接收多少文档。

为了成功地实现分页，我们需要一个可预测的文档顺序。要做到这一点，我们必须对它们进行排序：

```ts
import { Model } from 'mongoose';
import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Post, PostDocument } from './post.schema';

@Injectable()
export class PostsService {
  constructor(@InjectModel(Post.name) private postModel: Model<PostDocument>) {}

  async findAll() {
    return this.postModel.find().sort({ _id: 1 }).populate('author').populate('categories');
  }

  // ...
}
```

> 通过执行 `sort({id: 1})` 按升序排序。

上面，我们使用了 `MongoDB` 中 `id` 的一个重要特性。`MongoDB` 中的 `id` 由 `12` 个字节组成，其中 `4` 个字节是时间戳。在这样做的同时，我们需要意识到一些缺点：

- 时间戳值以秒为单位，在同一秒内创建的文档不能保证有效顺序
- id 是由可能具有不同系统时钟的客户端生成的。

根据 `id` 排序具有显著的优势，因为 `MongoDB` 在 [id 字段上创建了唯一的索引](https://docs.mongodb.com/manual/indexes/#default-_id-index)。这提高了按 `id` 对文档排序的性能。

#### 使用 skip 和 limit

实现上述方法的第一步是允许用户通过查询参数提供 `skip` 和 `limit`。为此，让我们使用 `class-validator` 和 `class-transformer`。

```ts
import { IsNumber, Min, IsOptional } from 'class-validator';
import { Type } from 'class-transformer';

export class PaginationParams {
  @IsOptional()
  @Type(() => Number)
  @IsNumber()
  @Min(0)
  skip?: number;

  @IsOptional()
  @Type(() => Number)
  @IsNumber()
  @Min(1)
  limit?: number;
}
```

> 如果想了解更多关于 `class-validator` 和 `class-transformer` 的信息，后面会有更多使用技巧。

现在，我们可以在控制器中使用上述参数：

```ts
import { Controller, Get, Query, UseInterceptors } from '@nestjs/common';
import PostsService from './posts.service';
import { Post as PostModel } from './post.schema';
import { PaginationParams } from '../utils/paginationParams';

@Controller('posts')
export default class PostsController {
  constructor(private readonly postsService: PostsService) {}

  @Get()
  async getAllPosts(@Query() { skip, limit }: PaginationParams) {
    const query = this.postModel
      .find()
      .sort({ _id: 1 })
      .skip(skip || 0)
      .populate('author')
      .populate('categories');

    if (limit) {
      query.limit(limit);
    }
  }

  // ...
}
```

由于这样做，用户现在可以指定他们要获取多少帖子以及跳过多少帖子。例如，请求 `/posts?skip=20&limit=10` 结果是 10 个帖子，而省略了前 20 个文档。

#### 文档计数

一种常见的方法是显示我们有多少页的帖子。为此，我们需要计算数据库中有多少文档。为此，我们需要使用[聚合框架](https://stackoverflow.com/questions/38765389/find-and-count-in-single-mongodb-query)或执行两个单独的查询。

```ts
async getAllPosts(@Query() { skip, limit }: PaginationParams) {
  const query = this.postModel
    .find()
    .sort({ _id: 1 })
    .skip(skip || 0)
    .populate('author')
    .populate('categories');

  if (limit) {
    query.limit(limit);
  }
  const results = await query;
  const count = await this.postModel.count();

  return { results, count };
}
```

现在在我们的响应结果中也有帖子文档的总数。

#### 优势

带有 `skip` 和 `limit` 的方法很常见，实现起来也很简单。它的最大优点是可以直接跳过多页文档。另外，可以直接更改用于排序的列，包括按多列进行排序。因此，如果预期的 `skip` 不是太大，且不一致是可以接受的，那么这是一个可行的解决方案。

#### 劣势

使用限制和偏移的解决方案在 SQL 数据库和 MongoDB 中得到了广泛的应用。不幸的是，它的性能还有改进的空间。使用 `skip()` 方法仍然需要数据库从集合的开始进行扫描。首先，数据库按 `id` 对所有文档进行排序。然后，`MongoDB` 丢弃指定数量的文档。对于大型集合，这可能需要相当多的工作。

除了性能问题，我们还需要考虑一致性。理想情况下，文档应该只在结果中出现一次。事实可能并非如此：

1. 第一个用户获取带有帖子的第 1 页
2. 在那之后，第二个用户在排序后创建了一个新的帖子，它最终出现在第 1 页
3. 第一个用户获取第 2 页

用户在第二个页面上再次看到第一个页面的最后一个元素。不幸的是，用户还错过了添加到第一个页面的元素，这更糟糕。

### Keyset 分页

如果我们非常关心性能，我们可能需要寻找上述方法的替代方案。其中之一是 `Keyset` 分页（[Keyset pagination](https://stackoverflow.com/questions/70519518/is-there-any-better-option-to-apply-pagination-without-applying-offset-in-sql-se)）。在这里，我们使用 `MongoDB` 中的 `id` 由时间戳组成的事实，并且可以进行比较：

1. 我们从 API 中获取一页文档
2. 我们检查最后一个文档的 id
3. 然后，我们请求 id 大于最后一个文档 id 的文档

由于采用了上述方法，数据库不再需要处理不必要的文档。首先，让我们为用户创建一种提供起始 id 的方法。

```ts
import { IsNumber, IsMongoId, Min, IsOptional } from 'class-validator';
import { Type } from 'class-transformer';

export class PaginationParams {
  @IsOptional()
  @IsMongoId()
  startId?: string;

  @IsOptional()
  @Type(() => Number)
  @IsNumber()
  @Min(0)
  skip?: number;

  @IsOptional()
  @Type(() => Number)
  @IsNumber()
  @Min(1)
  limit?: number;
}
```

现在，我们需要在服务中使用 `startId` 属性。

```ts
async getAllPosts(@Query() { skip, limit, startId }: PaginationParams) {
  const query = this.postModel
    .find({
      _id: {
        $gt: startId,
      },
    })
    .sort({ _id: 1 })
    .skip(skip || 0)
    .populate('author')
    .populate('categories');

  if (limit) {
    query.limit(limit);
  }
  const results = await query;
  const count = await this.postModel.count();

  return { results, count };
}
```

由于执行了 `$gt: startId`，用户只接收到在具有提供的 `id` 的帖子之后创建的帖子。

#### 优势

与基于偏移分页的方法相比， `Keyset` 分页最显著的优点是性能改进。此外，它还有助于解决用户在获取页面之间添加或删除元素的不一致问题。

#### 劣势

`Keyset` 分页的一大缺点是需要知道我们想从哪个文档开始。我们可以通过将其与基于偏移量的分页相结合来克服这个问题。这种方法的另一个问题是，用户很难一次跳过多个数据页面。

## Mongoose 中关于更新 PUT 和 PATCH 区别

在开发 `REST API` 时，有一组 `HTTP` 方法可供选择，例如 `GET`、`POST`、`PUT`、`PATCH` 和 `DELETE`。要了解的关键一点是，`HTTP` 方法在很大程度上是传统的。我们的工作是使它们以与规范一致的方式工作。例如，理论上，我们可以使用 `GET` 方法删除实体。然而，我们应该使我们的 `API` 具有可预见性，以便在后端开发人员和用户都能轻松理解。

很多 `HTTP` 方法都非常简单。然而，`PUT` 和 `PATCH` 方法值得深入研究。在本段中，我们将两者进行比较，并用 `NestJS` 和 `Mongoose` 实现它们。

### PUT

`PUT` 方法负责修改现有的实体。关于它的关键部分是它应该取代一个实体。因此，如果在执行 `PUT` 请求时不发送实体的字段，则应该从文档中删除缺失的字段。

```json
{
  "categories": [],
  "_id": "614fa87e4027d3141f28e9e7",
  "title": "关于 Mongoose 更新 PUT 和 PATCH 方法",
  "content": "...",
  "series": {
    "_id": "614fa8364027d3141f28e9e2",
    "name": "深入 NestJS"
  },
  "author": {
    "_id": "61350362017a80b8d443b012",
    "email": "jiayi@qq.com",
    "nickname": "jiayi"
  }
}
```

在上面，我们可以看到我们的帖子包含的属性。现在就进行 `PUT` 请求：

```json
{
  "_id": "614fa87e4027d3141f28e9e7",
  "categories": [],
  "title": "关于 Mongoose 更新 PUT 和 PATCH 方法",
  "content": "...",
  "author": {
    "_id": "61350362017a80b8d443b012",
    "email": "jiayi@qq.com",
    "nickname": "jiayi"
  }
}
```

上面关键的一点是，我们没有在请求正文中发送 `series` 属性。因为 `PUT` 方法应该替换整个实体，所以我们删除了 `series` 属性。

### Mongoose 使用 PUT

用 `Mongoose` 实现正确的 `PUT` 方法有很多种方法。`findByIdAndUpdate` 和 `findOneAndUpdate` 方法很常见，但默认情况下它们不会替换整个文档。相反，它们对它执行部分更新。因此，在请求体中不包含属性并不会删除它。我们可以用 `overwrite: true` 选项来修正这个问题。

```ts
import { Body, Controller, Param, Put, UseInterceptors } from '@nestjs/common';
import PostsService from './posts.service';
import { Post as PostModel } from './post.schema';
import { InjectModel } from '@nestjs/mongoose';
import { Post, PostDocument } from './post.schema';
import UpdatePostDto from './dto/updatePost.dto';

@Controller('posts')
export default class PostsController {
  constructor(@InjectModel(Post.name) private postModel: Model<PostDocument>) {}

  @Put(':id')
  async updatePost(@Param('id') id: string, @Body() postData: UpdatePostDto) {
    const post = await this.postModel
      .findByIdAndUpdate({ _id: id }, postData, { overwrite: true, new: true })
      .populate('author')
      .populate('categories')
      .populate('series');
    if (!post) {
      throw new NotFoundException();
    }
    return post;
  }

  // ...
}
```

> 通过设置 `new: true` 希望 `findByIdAndUpdate` 方法返回文档的修改版本。

由于做了上述操作，当我们更新一个文档时，我们将它作为一个整体替换，并删除不包含的字段。

我们还可以使用 `findOneAndReplace` 方法：

```ts
@Controller('posts')
@UseInterceptors(MongooseClassSerializerInterceptor(PostModel))
export default class PostsController {
  constructor(@InjectModel(Post.name) private postModel: Model<PostDocument>) {}

  @Put(':id')
  async updatePost(@Param('id') id: string, @Body() postData: UpdatePostDto) {
    const post = await this.postModel
      .findOneAndReplace({ _id: id }, postData, { new: true })
      .populate('author')
      .populate('categories')
      .populate('series');
    if (!post) {
      throw new NotFoundException();
    }
    return post;
  }

  // ...
}
```

### 阻止 id 更新

因为我们希望用户发送整个文档，所以他们也发送 `id` 属性。只要用户不更改 `id`，上述操作不会导致任何问题。这是因为这样做可能会导致意外的错误：

> MongoError: Plan executor error during findAndModify :: caused by :: After applying the update, the (immutable) field ‘\_id’ was found to have been altered

我们可以通过从 `PUT` 请求体中排除 `id` 属性来处理上述错误。

即使用户在请求中提供了 `id` 属性，我们也会排除它，不将它传递给 `findOneAndReplace` 或 `findByIdAndUpdate` 方法。请放心，因为 `MongoDB` 不会在这种情况下删除 `id` 属性，即使我们在这里实现 `PUT` 方法。

### PATCH

虽然 `PUT` 方法是一种常见且有效的选择，但它可能并不适用于所有情况。例如，在实现 `PUT` 方法时，我们假设 `API` 用户知道特定实体的所有细节。因为省略单个属性会导致删除它，所以他们需要小心。这个问题的解决方案可以是 `PATCH` 方法。

`PATCH` 方法于 2010 年引入 [HTTP 协议](https://datatracker.ietf.org/doc/html/rfc5789)，旨在对实体进行部分修改。该规范将其描述为一组描述应该如何修改资源的指令。实现 `PATCH` 方法最直接的方法是用部分文档处理正文。

```json
{
  "title": "A new title",
  "series": null
}
```

上面的请求通过更改 `title` 和删除 `series` 属性来修改帖子。请注意，要删除一个字段，我们需要显式地发送 `null`。多亏了这一特性，没有字段被意外删除。

### Mongoose 使用 PATCH

要使用 `Mongoose` 实现一个 `PATCH` 处理程序，我们可以使用 `findByIdAndUpdate` 方法，而不使用 `overwrite: true` 选项。首先，让我们在控制器中使用 `@Patch` 装饰器

```ts
import { Body, Controller, Param, Patch, UseInterceptors } from '@nestjs/common';
import PostsService from './posts.service';
import { Post as PostModel } from './post.schema';
import { InjectModel } from '@nestjs/mongoose';
import { Post, PostDocument } from './post.schema';
import UpdatePostDto from './dto/updatePost.dto';

@Controller('posts')
export default class PostsController {
  constructor(@InjectModel(Post.name) private postModel: Model<PostDocument>) {}

  @Patch(':id')
  async updatePost(@Param('id') id: string, @Body() postData: UpdatePostDto) {
    const post = await this.postModel
      .findByIdAndUpdate({ _id: id }, postData, { new: true })
      .populate('author')
      .populate('categories')
      .populate('series');
    if (!post) {
      throw new NotFoundException();
    }
    return post;
  }

  // ...
}
```

为了使上述正确工作，我们还需要通过添加 `@IsOptional()` 来修改 `DTO`：

```ts
import { IsString, IsNotEmpty, IsOptional } from 'class-validator';
import { User } from '../../users/user.schema';
import { Exclude, Type } from 'class-transformer';
import { Category } from '../../categories/category.schema';
import { Series } from '../../series/series.schema';

export class UpdatePostDto {
  @IsOptional()
  @Exclude()
  _id?: string;

  @IsString()
  @IsNotEmpty()
  @IsOptional()
  title?: string;

  @IsString()
  @IsNotEmpty()
  @IsOptional()
  content?: string;

  @Type(() => Category)
  @IsOptional()
  categories?: Category[];

  @Type(() => User)
  @IsOptional()
  @IsNotEmpty()
  author?: User;

  @Type(() => Series)
  @IsOptional()
  series?: Series;
}
```

不过还有更简单的方式：

```ts
import { PartialType } from '@nestjs/swagger';

export class UpdatePostDto extends PartialType(CreatePostDto) {}
```

## 总结

在本文中，我们简单了解数据库设计三大范式，以及介绍如何使用 `NestJS` 在 `MongoDB` 中定义文档之间的关系。我们已经学习了各种类型的关系，并考虑了如何存储引用以提高性能。我们了解了什么是虚拟属性以及它们的用途。我们使用它们来添加简单的属性和填充来自其他集合的文档。为了更好地掌握虚拟属性的概念，我们还研究了 `getter` 和 `setter`。我们解释了不同类型的索引，例如惟一索引、单字段索引和复合索引。我们还了解了文本索引，并使用它们实现了一个搜索功能。我们还知道，创造优势可以加快一些查询，同时降低另一些查询的速度。我们通过描述 `MongoDB` 中的事务的原理和用例来介绍它们。我们还在 `Mongoose` 的应用程序中实现了它们。理解事务绝对是值得的，因为它们可以大大提高应用程序的可靠性。我们比较了 `MongoDB` 的两种分页类型。我们已经考虑了 `Keyset` 分页和偏移分页的优缺点。它们都不是完美的，但是结合它们可以涵盖很多不同的情况。为特定的工作选择合适的工具是至关重要的。最后实现更新功能的各种方法 `PUT` 和 `PATCH` 区别，我们可以为特定的情况选择最佳的方法。当选择上述其中之一时，我们应该遵循规范并可预测和透明地实现我们的 `API`。关于 `Mongoose` 还有很多东西要细说，所以请继续关注后续文章。
