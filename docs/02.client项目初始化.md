# Client 项目初始化

## 初始化 Client 项目

### 使用 Nx Console 初始化

安装 VS Code [Nx Console](https://marketplace.visualstudio.com/items?itemName=nrwl.angular-console) 插件。

1. 选择 Generate
2. 就好弹出选择界面，输入 `nest`。（**注意**：里面有 2 种，一种是 `@nestjs/schematics` 开头，一种是 `@nx/nest` 开头）
3. 选择 `@nx/nest:application`
4. 在 `name` 处输入项目名字
5. 右上角 `Run` 点击即可

### 使用命令行初始化

```sh
npx nx generate @nx/nest:application --name=项目名字 --no-interactive
```

## 启动 Client 项目

### 使用 Nx Console 启动

左下角 `PROJECTS` 有项目名字，点击展开，有可执行的命令：

- build 开发发布
  - production 生产发布
- serve 开发启动
- lint 风格检查
- test 单元测试

点击 `serve` 右边三角形完成启动。

### 使用命令行启动

```sh
nx serve 项目名字
or
npm run start 项目名字
```

访问 `http://localhost:端口号(默认 3333)/api`，出现一个 JSON 文件表示正常的运行。

## Model-View-Controller

默认情况下，`Nest` 会在底层使用 `Express` 库。因此，在 `Express` 中使用 `MVC(模型-视图-控制器)` 模式的技术也适用于 `Nest`。

`Nest` 官网文档有一个简单 [MVC](https://docs.nestjs.com/techniques/mvc) 示例。使用的 [Handlebars](https://handlebarsjs.com/) 模板引擎。

### 模板引擎选择

选择的模板引擎目的：

- 可维护性（后期改起来方便）
- 可扩展性（想要增加功能，增加需求方便）
- 开发效率提高（程序逻辑组织更好，调试方便）
- 容易识别（不容易写错，vs code 默认支持）

需要考虑两点：实际业务需求、个人偏好。

首先考虑业务需求，需要支持以下几点特性:

- 支持模版继承(extend)
- 支持模版扩展(block)
- 支持模版组合(include)
- 支持预编译(precompile)

个人偏好：`handlebars` 和 `ejs`。

`ejs` 是一个很常用的模板引擎。`cnode` 就是用 `ejs`，`egg-cnode` 用的改造的`egg-ejs`。

### 为什么选择 Handlebars

1. 全球最受欢迎的模板引擎，简单，自由，高效。
2. `Nest` 官网 mvc 示例使用 `handlebars`
3. 之前都是用 `ejs`，我想换个活法，折腾一下

### 安装 Handlebars

```sh
npm install hbs handlebars-helpers handlebars-layouts --save
```

### 使用 Handlebars

创建 `views` 模板目录

```sh
mkdir apps/client/src/views
```

在 `main.ts` 配置

```ts
...
// 引入依赖包
import { NestExpressApplication } from '@nestjs/platform-express';
import * as helpers from 'handlebars-helpers';
import * as layouts from 'handlebars-layouts';
import * as hbs from 'hbs';
import { join } from 'path';

async function bootstrap() {
  // 需要 create 泛型加上 NestExpressApplication 接口，不然有些方法报错
  const app = await NestFactory.create<NestExpressApplication>(AppModule);
  // 初始化 handlebars-helpers
  helpers({ handlebars: hbs });
  // 初始化 handlebars-layouts(必须在 handlebars-helpers 后面)
  layouts.register(hbs.handlebars);
  // 数据和模板关联
  hbs.localsAsTemplateData(app);
  // 注册静态资源路径和访问路径前缀
  app.useStaticAssets(join(__dirname, 'assets'), {
    prefix: '/assets',
  });
  // 注册模板引擎路径
  app.setBaseViewsDir(join(__dirname, 'views'));
  // 设置模板引擎
  app.setViewEngine('hbs');
  // 设置模板引擎公共页面
  app.set('view options', { layout: 'layout.hbs'});
  // 注册 partials 包含路径
  hbs.registerPartials(join(__dirname, 'views'));
  ...
}
```

在 `views` 创建一个 `index.hbs`

```sh
touch apps/client/src/views/index.hbs
```

里面写入

```html
<h1>{{message}}</h1>
```

在 `app.controller.ts` 的 `getData()` 方法上面加上模板渲染装饰器 `@Render('index')`。

保存文件，刷新浏览器，就会看到报错：

```json
{
  "statusCode": 500,
  "message": "Internal server error"
}
```

在命令行里面也会有红色错误：

```text
ERROR [ExceptionsHandler] Failed to lookup view "index" in views directory "G:\github\nest-cnode\dist\apps\client\views"
```

为什么是 `dist\apps\client\views` 而不是 `apps\client\src\views`。如果你配置过 `webpack`，对这个就不奇怪。

在 `project.json` 文件里面修改一下配置：

```json
{
  ...
  // 追加模板引擎目录即可
  "assets": ["apps/client/src/assets", "apps/client/src/views"]
  ...
}
```

重启项目，你就会看到 `dist\apps\client\views\index.hbs` 文件，在刷新浏览器，还是会报 500 错误，因为我们没有 `layout.hbs` 文件。

```sh
touch apps/client/src/views/layout.hbs
```

在里面写个简单 `html:5` 模板，最重要在页面放入插槽

```html
{{{body}}}
```

刷新浏览器就会看到加粗的 `Welcome to client!`。

至此，`handlebars` 配置和基本搭建已经完成，后面可以根据自己需要修改。

> 关于 `handlebars` 语法和一些特性，后面一节专门介绍。篇幅有限，这里不展开。当然你也可以去 `handlebars` 官网学习。

## 关于 client views build 问题

### 问题

1. 在 `nest` 分支中，使用的 `loader` 和 `loader-connect` 加载静态资源。
2. 现在流行 `webpack` 打包构建。`nx` 里开发运行、发布打包都是用 `webpack`。
3. 之前 `views` 文件夹里面更新内容以后，浏览器不会自动刷新，这种基建有点原始。

### 解决

`nx` 提供 `webpackConfig`，方便我们给 `webpack` 配置扩展，有点类似于 `vue-cli` 的 `vue.config.js`。

```js
/**
 * 扩展打包配置
 * @param {object} webpackConfig nx webpack 默认配置
 * @param {object} nxContext nx 提供当前项目配置参数
 * @returns 返回 webpack 配置
 */
module.exports = (webpackConfig, nxContext) => {
  // 自定义配置
  return webpackConfig;
};

// nxContext 参数
/* {
  options: { 大部分参数都在 project.json 文件可以找到
    outputPath: 输出目录,
    main: 入口,
    tsConfig: ts编译配置,
    assets: 拷贝资源配置,
    webpackConfig: 自定义 webpack 配置,
    generatePackageJson: 根据项目引用，自动生成 package.json，帮我们剔除无关依赖,
    watch: true,
    sourceMap: true,
    progress: false,
    externalDependencies: 'all',
    statsJson: false,
    verbose: false,
    extractLicenses: false,
    optimization: false,
    fileReplacements: [],
    buildLibsFromSource: true,
    tsPlugins: [],
    outputFileName: 输出文件名（nest-cli 也是支持 webpack 打包的，默认是 tsc）,
    root: 工程目录,
    sourceRoot: 项目源码目录,
    projectRoot: 项目目录,
    additionalEntryPoints: []
  },
  configuration: undefined 只有 --configuration 参数才会有
}
 */
```

> 实际这个是修改 `main.js` 的，无法处理我们的 `views`，只能另辟路径。

`Webpack` 还提供 [Node Api](https://webpack.js.org/api/node) `#webpack()` 方法，方便给我们在脚本里面，或者其他地方运行。我们可以把 `views` 变成子 `webpack` 单独打包。

但是我们不能直接在自定义 `webpack.config.js` 函数执行 `Webpack` 方法，这样会出现子 `webpack` 方法不执行问题，可以安装 `webpack-cli`，执行 `webpack build` 来打包发布 `views`。

## client views 打包处理

前面我们分析原因，可以借助 `webpack` Node Api 来实现打包：

在**前端**开发模式中，我们可以借助 `webpack` 和 `webpack-dev-server` 完成打包：

```js
const Webpack = require('webpack');
const WebpackDevServer = require('webpack-dev-server');
const webpackConfig = require('./webpack.config.js');

const compiler = Webpack(webpackConfig);
const devServerOptions = { ...webpackConfig.devServer, open: true };
const server = new WebpackDevServer(devServerOptions, compiler);

server.startCallback(() => {
  console.log('Successfully started server on http://localhost:8080');
});
```

`webpack-dev-server` 内置了 `express` 服务器，如果要完成**服务端**打包，我们就不能直接使用 `webpack-dev-server` 了，需要使用更底层的 `webpack-dev-middleware`，也是 `express` 的一个中间件，监听文件变化，编译 `webpack` 配置。

```js
const express = require('express');
const webpack = require('webpack');
const webpackDevMiddleware = require('webpack-dev-middleware');

const app = express();
const config = require('./webpack.config.js');
const compiler = webpack(config);

app.use(
  webpackDevMiddleware(compiler, {
    publicPath: config.output.publicPath, // 这里需要设置 /
    serverSideRender: true, // 服务端渲染
    writeToDisk: true, // 把文件写到磁盘
  })
);

// Serve the files on port 3000.
app.listen(3000, () => {
  console.log('Example app listening on port 3000!\n');
});
```

生产打包就比较简单：

```js
const webpack = require('webpack');
const webpackConfig = require('./webpack.config.js');
const compiler = webpack(webpackConfig);
compiler.run((err, stats) => {
  if (err) {
    console.error(err);
    return;
  }
  const info = stats.toJson();

  if (stats.hasErrors()) {
    console.error(info.errors);
  }

  if (stats.hasWarnings()) {
    console.warn(info.warnings);
  }

  console.log('打包完成', stats.toString());

  compiler.close((closeErr) => {
    if (closeErr) {
      console.error(closeErr);
    }
  });
});
```

我们在使用 `Angular`、`React`、`Vue` 时候，都会有一个 `HMR（Hot Module Replacement）` -- 模块热更新功能，对应还有一个叫页面热重载。

- 热重载：顾名思义重新加载，使用 `window.location.reload()` 刷新界面以达到更新的目的, 比较有名 node 插件 `live-server`、`browser-sync` 等。
- 热更新：只更新修改的文件，以组件为模块更新，不会刷新整个界面。`React`、`Vue` 效果比较明显。

无论热重载和热更新机制都很简单理解，都是利用长连接进行通讯，注入 HTML 5 服务器发送事件 `SSE(server-sent event)` 或 `Web Socket` 和心跳检测的相关机制，主要是为了服务器和客户端的通信，当服务器文件发生变化的时候能够方便通知到客户端。

大概流程步骤：

1. 首先启动 `dev-server`, 往当前的 `options.entry` 中插入相关的 `SSE` 相关的代码。
2. 监听 `webpack done` 的 `compiler.hooks.done.tap` 节点从 `stats` 中获取到最新的 `hash` 值，传递给客户端，如果只是做热重载到这步就可以结束了，使用 `window.location.reload();`
3. 客户端获取 `lastHash.hot-update.json` 文件，获取到当前更新了的文件的 `chunkId`。
4. 根据当前更新的 `chunkId` 去拿 `chunkID.lastHash.hot-update.js` 文件
5. 执行 `webpackHotUpdate`，从现有的 `cache` 中找到当前的 `chunkId` 对应的旧的数据信息，进行更新并执行当前最新的 `chunk` 代码，以便于更新 `cache`，接着执行对应的 `hot.accept` 代码来实现 `render` 操作。

一般会借助 `webpack-hot-middleware` 和 `webpack.HotModuleReplacementPlugin` 实现热更新。

服务端渲染页面和前端渲染页面有所不同，没有模块概念，我们这里只需要实现热重载即可。

前面我们提到到 `live-server`、`browser-sync`，都是比较流行的自动刷新浏览器好插件，但和 `express` 集成就有些冲突，因为它们自带一个服务器。这里选择一个工具可以实现浏览器刷新 `reload`, 刚好可以和 `Express` 集成。

```js
const express = require('express');
const reload = require('reload');
const webpack = require('webpack');
const webpackDevMiddleware = require('webpack-dev-middleware');

const app = express();
const config = require('./webpack.config.js');
const compiler = webpack(config);
// 创建浏览器刷新服务
const reloadServer = await reload(app);

app.use(
  webpackDevMiddleware(compiler, {
    publicPath: config.output.publicPath, // 这里需要设置 /
    serverSideRender: true, // 服务端渲染
    writeToDisk: true, // 把文件写到磁盘
  })
);

complier.hooks.done.tap('done', (stats) => {
  const info = stats.toJson();
  if (stats.hasWarnings()) {
    console.warn(info.warnings);
  }

  if (stats.hasErrors()) {
    console.error(info.errors);
    return;
  }
  console.log('编译完成', stats.toString());
  // 编译完成通知浏览器刷新
  reloadServer.reload();
});

// Serve the files on port 3000.
app.listen(3000, () => {
  console.log('Example app listening on port 3000!\n');
});
```

### Webpack 配置简述

关于配置，这里有详细[文档](https://webpack.js.org/configuration/#options)，

#### 关于 `entry` 处理

多入口和单入口是有区别的，单入口可以设定唯一，比如 `main.js`。但是多入口就不行，我们希望动态生成，但是动态生成需要一些约定，符合约定我们才认为它们是入口，否则忽略。

- 命名约定：比如文件夹里 `main.js`，就是入口地址，当前文件夹就是属性名。
- 后缀约定：比如文件夹里 `index.entry.js`，就是入口地址，当前文件夹 + 文件前缀就是属性名。

命名约定相当于模块比较聚合，缺点每个页面都需要一个文件夹。
后缀约定文件结构层次更少，一个文件夹里面可以有多个入口，缺点比较松散，需要文件名精准一一对应，不允许出错。

先看文件结构：

```text
layout.hbs 公共页面
--- index 页面文件夹
      |
      | --- index.hbs 页面模板
      | --- main.js 页面入口
      | --- style.scss 页面样式
      | --- partials 页面子模板
```

我现在需要登录，注册 2 个页面，

如果按命名约定：

```text
layout.hbs 公共页面
--- auth 模块文件夹
      |
      | --- login 登录
              | --- index.hbs 页面模板
              | --- main.js 页面入口
              | --- style.scss 页面样式
              | --- partials 页面子模板
      | --- register 注册
              | --- index.hbs 页面模板
              | --- main.js 页面入口
              | --- style.scss 页面样式
              | --- partials 页面子模板
```

如果按后缀约定：

```text
layout.hbs 公共页面
--- auth 模块文件夹
      |
      | --- partials 共用页面子模板
      | --- login.template.hbs 登录页面模板
      | --- login.main.js 页面入口
      | --- login.scss 页面样式
      | --- register.template.hbs 注册页面模板
      | --- register.main.js 页面入口
      | --- register.scss 页面样式
```

> 小孩子才做选择，我都要。肯定不行，统一风格是一个好的开发方法，这里我们选择后缀约定。后面我会做一个模板生成工具，自动处理这些问题。

`Angular` 里面就是这两种方式结合：

```text
layout.hbs 公共页面
--- user 页面文件夹
      |
      | --- user.template.hbs 页面模板
      | --- user.main.js 页面入口
      | --- user.scss 页面样式
      | --- partials 页面子模板
```

> 它也可以扁平化处理，推荐上面这种方式。保持独立，方便维护。

#### 关于模板处理

我们在 `src/views` 文件夹里写的源文件，最后经过 `webpack` 处理，生成到 `dist/views` 里。对于模板生成，最好的选择是 `HtmlWebpackPlugin`，它主要是处理静态 `html`，内置 `lodash.template` 处理动态模板，类似 `ejs` 常规语法。

对于服务端渲染模板来说，不需要处理模板变量语法，如果选择 `ejs` 模板引擎就要注意了。我这里选择 `handlebars` 就可以直接规避这个问题，它们俩的语法不一样。

`HtmlWebpackPlugin` 会帮我们做几件事情：

1. 把模板处理完成，写入指定文件内
2. 动态插入资源（js、css）到文件内（根据 webpack 处理）
3. 处理模板变量动态编译内容
4. 压缩模板内容

对于服务端模板来说，我们不需要压缩和处理模板变量。

我们重点来说一下怎么处理动态插入资源，在我们模板里面，分为页面模板，内容模板。

页面模板需要插入资源，内容模板不需要插入资源。

好在 `HtmlWebpackPlugin` 提供足够强大的扩展能力 [hooks](https://github.com/jantimon/html-webpack-plugin#events):

每个 `hooks` 作用不一样，我们这里唯一能选择就是 `afterTemplateExecution`，它里面有资源信息和处理完成的待生成模板内容。

`afterTemplateExecution` 返回内容：

```ts
AsyncSeriesWaterfallHook<{
  html: string,  // 处理内容模板
  headTags: Array<HtmlTagObject | HtmlTagObject>, // 资源 tags：js，css
  bodyTags: Array<HtmlTagObject | HtmlTagObject>, // 资源 tags：js
  outputName: string, // 输出文件地址
  plugin: HtmlWebpackPlugin, // HtmlWebpackPlugin 实例
}>
```

我们就可以利用这写信息，来处理我们的模板。

如果我们正常在 `HtmlWebpackPlugin` 模板里面动态生成资源

```html
{{!--style--}} {{#content "style" mode="append"}} <% for (var css in htmlWebpackPlugin.files.css) { %>
<link href="<%= htmlWebpackPlugin.files.css[css] %>" rel="stylesheet" />
<% } %> {{/content}} {{!--script--}} {{#content "script" mode="append"}} <% for (var js in htmlWebpackPlugin.files.js) {
%>
<script type="text/javascript" src="<%= htmlWebpackPlugin.files.js[js] %>"></script>
<% } %> {{/content}}
```

> 其他看不懂奇怪东西是 `handlebars` 语法，后面会有一节来介绍，这里忽略它。

在 hooks 里面处理：

```js
const scripts = [],
  styles = [];

for (const tag of headTags) {
  switch (tag.tagName) {
    case 'script': {
      scripts.push(tag.attributes);
      break;
    }
    case 'link': {
      styles.push(tag.attributes);
      break;
    }
  }
}

let resources = '\r\n';

resources += '{{#content "style" mode="append"}}\r\n';

styles.forEach((item) => {
  resources += `<link href="${item.href}" rel="${item.rel}">\r\n`;
});

resources += '{{/content}}\r\n';
resources += '{{#content "script" mode="append"}}\r\n';

scripts.forEach((item) => {
  resources += `<script type="${item.type ?? 'text/javascript'}" ${item.defer ? 'defer' : ''} src="${
    item.src
  }"></script>\r\n`;
});

resources += '{{/content}}\r\n';
```

只需要把 `resources` 添加到 `afterTemplateExecution.html` 即可。

```js
class HandlebarsRenderPlugin {
  apply(compiler) {
    compiler.hooks.compilation.tap('HandlebarsRenderPlugin', (compilation) => {
      HtmlWebpackPlugin.getHooks(compilation).afterTemplateExecution.tapAsync('HandlebarsRenderPlugin', (data, cb) => {
        // 这里区分页面模板和内容模板
        if (data.plugin.userOptions.chunks) {
          data.html += appendResource(data.headTags);
        }
        cb(null, data);
      });
    });
  }
}
```

我们就实现一个简易的 webpack Plugin。功能很简单，就是改变模板的内容。这个 hooks 还可以修复和 `html-loader` 冲突。

#### html-webpack-plugin 和 html-loader 冲突问题

问题：如果使用 `html-loader` 来处理 `html` 模版文件中的 `url`，会导致 `html-webpack-plugin` 的 `ejs` 模版语法失效。

原因：`html-loader` 会把原始的 `html` 模版，编译成一个 `js` 模块样式的字符串，导致`html-webpack-plugin` 解析的时候，发现文件已经被编译了，会直接跳过模版语法的检测。

解决方案:

1. 在 `html-loader` 执行之前，执行一个自定义的 `loader` 来预先编译自定义的模版语法。
2. 去掉 `html-loader`，在模板里使用 `<%= require('../images/logo.png') %>` 方式引入 `url` 资源。
3. 自定义一个 `FixTemplateParametersPlugin` 获取 `HtmlWebpackPlugin` 的钩子 `afterTemplateExecution` 编译自定义的模版语法。

这个冲突问题，也可以帮我们解决一些问题，比如我想要服务端模板引擎，不希望 `html-webpack-plugin` 处理模板变量，就可以借助 `html-loader` 帮我们跳过这个动作。

> 有一个比较麻烦问题，服务端模板里循环语法中的资源引入。这种问题 `html-webpack-plugin` 和 `html-loader` 都无解。

#### 关于资源处理

我们使用 webpack v5 版本，处理资源不用那么麻烦，可以使用新特性 [Asset Modules](https://webpack.js.org/guides/asset-modules/#resource-assets)

- asset/resource 对标 file-loader
- asset/inline 对标 url-loader
- asset/source 对标 raw-loader
- asset 是 asset/resource 和 asset/inline 合体

```js
{
  test: /\.hbs$/i,
  loader: 'html-loader',
  options: {
    sources: {
      urlFilter: (attribute, value, resourcePath) => {
        // The `attribute` argument contains a name of the HTML attribute.
        // The `value` argument contains a value of the HTML attribute.
        // The `resourcePath` argument contains a path to the loaded HTML file.
        // /assets/ 认为这个开头不需要处理
        if (value.startsWith('/assets/')) {
          return false;
        }

        return true;
      },
    },
  },
},
// images
{
  test: /\.(png|jpe?g|gif|svg)(\?.*)?$/,
  type: 'asset',
  generator: {
    filename: `assets/images/[name][ext]`, // 局部指定输出位置
  },
  parser: {
    dataUrlCondition: {
      maxSize: 8 * 1024, // 限制于 8kb
    },
  },
},
// fonts
{
  test: /\.(woff2?|eot|ttf|otf)(\?.*)?$/,
  type: 'asset',
  generator: {
    filename: `assets/fonts/[name][ext]`, // 局部指定输出位置
  },
  parser: {
    dataUrlCondition: {
      maxSize: 8 * 1024, // 限制于 8kb
    },
  },
},
```

`html-loader` 处理页面静态资源的 url 链接，写的是相对路径，如果我们不希望被处理，可以写成绝对路径，通过 `urlFilter` 过滤处理。

#### 关于 css 和 js 处理

关于 css 处理，前端开发处理都是 `style-loader`、`css-loader`、`postcss-loader`、`sass-loader`。

```js
// scss
{
  test: /\.scss$/,
  use: [
    MiniCssExtractPlugin.loader,
    {
      loader: 'css-loader'
    },
    {
      loader: 'postcss-loader',
      options: {
        postcssOptions: {
          plugins: [
            'autoprefixer',
          ],
        },
      },
    },
    {
      loader: 'sass-loader'
    },
  ],
},
{
  test: /\.js$/,
  use: {
    loader: 'babel-loader',
    options: {
      presets: ['@babel/preset-env', {
      "useBuiltIns": "usage", // 按需引入 core-js 中的模块
      "corejs": 3, // 必须指定 core-js 版本
    }],
    },
  },
  exclude: /node_modules/,
},
```

在服务端模板里面，需要把 `style-loader` 换成 `MiniCssExtractPlugin.loader`，打包成单独文件，对应 `HandlebarsRenderPlugin` 单独处理地方。

```js
plugins: [
  new MiniCssExtractPlugin({
    filename: 'assets/css/[name].css',
    linkType: 'text/css',
  }),
],
```

关于 js ，一切交给 `babel` 处理。默认 `@babel/preset-env` 只会帮我们处理语法转换，例如箭头函数，不会处理新 API，例如 Promise。就需要 `polyfill` 来处理。

目前使用最多的 `polyfill` 是 `core-js`。想要按需引用必须要配置 `useBuiltIns`，如果不配置，`babel` 将不会处理 `Promise`、`Map`、`Set`、`Symbol` 等全局对象；`corejs` 也要同时配置，`v2` 的版本可以处理全局对象，但实例方法并不处理，所以这里用 `v3` 的版本。

#### 关于别名设置

别名作用相当于 `tsConfig` 的 `paths`，我们可以使用访问的映射，最终访问资源的全路径，方便维护管理。

```js
resolve: {
  alias: {
    '@': path.resolve('root/src', 'views'),
  },
},
```

> 我们这里 `@` 不应是 `src`, 必须是 `src/views`。

#### 关于打包压缩

webpack 提供压缩插件：

- js 压缩 [terser-webpack-plugin](https://webpack.js.org/plugins/terser-webpack-plugin/#getting-started)
- css 压缩 [css-minimizer-webpack-plugin](https://webpack.js.org/plugins/css-minimizer-webpack-plugin/)
- img 压缩 [image-minimizer-webpack-plugin](https://webpack.js.org/plugins/image-minimizer-webpack-plugin/)
- html 压缩 [html-minimizer-webpack-plugin](https://webpack.js.org/plugins/html-minimizer-webpack-plugin/)
- json 压缩 [json-minimizer-webpack-plugin](https://webpack.js.org/plugins/json-minimizer-webpack-plugin/)

```js
optimization: {
    minimize: true,
    minimizer: [
      // 压缩插件
    ],
  },
```

关于压缩 `html` 无需压缩，因为压缩可能引起模板引擎出错，顾不需要压缩处理。只需要压缩 `js`、`css`、`img`。开启 `gzip` 压缩和长缓存。

> 尺有所短，寸有所长。 合理利用技术的优势，发挥所长。
